// This file is generated. Do not modify by hand.
// XML documentation file not found. To check if public methods have XML comments,
// make sure the XML doc file is present and located next to the scraped dll
namespace UnityEngine.Splines
{
    public struct BezierCurve : System.IEquatable<UnityEngine.Splines.BezierCurve>
    {
        public Unity.Mathematics.float3 P0;
        public Unity.Mathematics.float3 P1;
        public Unity.Mathematics.float3 P2;
        public Unity.Mathematics.float3 P3;
        public Unity.Mathematics.float3 Tangent0 { get; set; }
        public Unity.Mathematics.float3 Tangent1 { get; set; }
        public BezierCurve(Unity.Mathematics.float3 p0, Unity.Mathematics.float3 p1) {}
        public BezierCurve(UnityEngine.Splines.BezierKnot a, UnityEngine.Splines.BezierKnot b) {}
        public BezierCurve(Unity.Mathematics.float3 p0, Unity.Mathematics.float3 p1, Unity.Mathematics.float3 p2) {}
        public BezierCurve(Unity.Mathematics.float3 p0, Unity.Mathematics.float3 p1, Unity.Mathematics.float3 p2, Unity.Mathematics.float3 p3) {}
        public virtual bool Equals(object obj);
        public virtual bool Equals(UnityEngine.Splines.BezierCurve other);
        public static UnityEngine.Splines.BezierCurve FromTangent(Unity.Mathematics.float3 pointA, Unity.Mathematics.float3 tangentOutA, Unity.Mathematics.float3 pointB, Unity.Mathematics.float3 tangentInB);
        public virtual int GetHashCode();
        public static bool operator ==(UnityEngine.Splines.BezierCurve left, UnityEngine.Splines.BezierCurve right);
        public static bool operator !=(UnityEngine.Splines.BezierCurve left, UnityEngine.Splines.BezierCurve right);
    }

    public struct BezierKnot : UnityEngine.ISerializationCallbackReceiver
    {
        public Unity.Mathematics.float3 Position;
        public Unity.Mathematics.quaternion Rotation;
        public Unity.Mathematics.float3 TangentIn;
        public Unity.Mathematics.float3 TangentOut;
        public BezierKnot(Unity.Mathematics.float3 position, Unity.Mathematics.float3 tangentIn, Unity.Mathematics.float3 tangentOut, Unity.Mathematics.quaternion rotation) {}
        public virtual void OnAfterDeserialize();
        public virtual void OnBeforeSerialize();
        public static UnityEngine.Splines.BezierKnot operator +(UnityEngine.Splines.BezierKnot knot, Unity.Mathematics.float3 rhs);
        public static UnityEngine.Splines.BezierKnot operator -(UnityEngine.Splines.BezierKnot knot, Unity.Mathematics.float3 rhs);
        public UnityEngine.Splines.BezierKnot Transform(Unity.Mathematics.float4x4 matrix);
    }

    public static class CurveUtility
    {
        public static float ApproximateLength(UnityEngine.Splines.BezierCurve curve);
        public static float CalculateLength(UnityEngine.Splines.BezierCurve curve, int resolution = 30);
        public static Unity.Mathematics.float3 EvaluateAcceleration(UnityEngine.Splines.BezierCurve curve, float t);
        public static float EvaluateCurvature(UnityEngine.Splines.BezierCurve curve, float t);
        public static Unity.Mathematics.float3 EvaluatePosition(UnityEngine.Splines.BezierCurve curve, float t);
        public static Unity.Mathematics.float3 EvaluateTangent(UnityEngine.Splines.BezierCurve curve, float t);
        public static void Split(UnityEngine.Splines.BezierCurve curve, float t, out UnityEngine.Splines.BezierCurve left, out UnityEngine.Splines.BezierCurve right);
    }

    public struct DataPoint<T> : System.IComparable<float>, System.IComparable<UnityEngine.Splines.DataPoint<T>>, UnityEngine.Splines.IDataPoint
    {
        public virtual float Time { get; set; }
        public T Value { get; set; }
        public DataPoint(float t, T value) {}
        public virtual int CompareTo(float other);
        public virtual int CompareTo(UnityEngine.Splines.DataPoint<T> other);
        public virtual string ToString();
    }

    public interface IDataPoint
    {
        public abstract float Time { get; set; }
    }

    public interface IInterpolator<T>
    {
        public abstract T Interpolate(T from, T to, float t);
    }

    [System.Reflection.DefaultMember(@"Item")] public interface ISpline
    {
        public abstract bool Closed { get; }
        public abstract UnityEngine.Splines.BezierKnot this[int index] { get; }
        public abstract int KnotCount { get; }
        public abstract float CurveDistanceToTime(int index, float distance);
        public abstract UnityEngine.Splines.BezierCurve GetCurve(int index);
        public abstract float GetCurveLength(int index);
        public abstract float GetLength();
        public struct DistanceToTime
        {
            public float distance;
            public float time;
        }
    }

    public interface ISplineProvider
    {
        public abstract System.Collections.Generic.IEnumerable<UnityEngine.Splines.Spline> Splines { get; }
    }

    [System.Reflection.DefaultMember(@"Item")] public struct NativeSpline : System.IDisposable, UnityEngine.Splines.ISpline
    {
        public virtual bool Closed { get; }
        public virtual UnityEngine.Splines.BezierKnot this[int index] { get; }
        public virtual int KnotCount { get; }
        public Unity.Collections.NativeArray<UnityEngine.Splines.BezierKnot> Knots { get; }
        public NativeSpline(System.Collections.Generic.IList<UnityEngine.Splines.BezierKnot> knots, bool closed, Unity.Collections.Allocator allocator = 2) {}
        public NativeSpline(System.Collections.Generic.IList<UnityEngine.Splines.BezierKnot> knots, bool closed, Unity.Mathematics.float4x4 transform, Unity.Collections.Allocator allocator = 2) {}
        public virtual float CurveDistanceToTime(int index, float dist);
        public virtual void Dispose();
        public virtual UnityEngine.Splines.BezierCurve GetCurve(int index);
        public virtual float GetCurveLength(int curveIndex);
        public virtual float GetLength();
    }

    public enum PathIndexUnit
    {
        public const UnityEngine.Splines.PathIndexUnit Distance = 0;
        public const UnityEngine.Splines.PathIndexUnit Knot = 2;
        public const UnityEngine.Splines.PathIndexUnit Normalized = 1;
        public int value__;
    }

    [System.Reflection.DefaultMember(@"Item")] public class Spline : UnityEngine.Splines.ISpline
    {
        public event System.Action changed;
        public virtual bool Closed { get; set; }
        public UnityEngine.Splines.SplineType EditType { get; set; }
        public virtual UnityEngine.Splines.BezierKnot this[int index] { get; set; }
        public virtual int KnotCount { get; }
        public System.Collections.Generic.IEnumerable<UnityEngine.Splines.BezierKnot> Knots { get; }
        public Spline() {}
        public Spline(System.Collections.Generic.IEnumerable<UnityEngine.Splines.BezierKnot> knots, bool closed = False) {}
        public Spline(int knotCapacity, bool closed = False) {}
        public void AddKnot(UnityEngine.Splines.BezierKnot knot);
        public void Copy(UnityEngine.Splines.Spline toCopy);
        public virtual float CurveDistanceToTime(int index, float dist);
        public virtual UnityEngine.Splines.BezierCurve GetCurve(int index);
        public virtual float GetCurveLength(int index);
        public virtual float GetLength();
        public void InsertKnot(int index, UnityEngine.Splines.BezierKnot knot);
        protected virtual void OnSplineChanged();
        public void Resize(int newSize);
        public UnityEngine.Splines.BezierKnot[] ToArray();
        public Unity.Collections.NativeArray<UnityEngine.Splines.BezierKnot> ToNativeArray(Unity.Collections.Allocator allocator);
        public UnityEngine.Splines.NativeSpline ToNativeSpline(Unity.Collections.Allocator allocator = 2);
        public UnityEngine.Splines.NativeSpline ToNativeSpline(Unity.Mathematics.float4x4 transform, Unity.Collections.Allocator allocator = 2);
        public void Warmup();
    }

    public struct SplineComputeBufferScope<T> : System.IDisposable where T : UnityEngine.Splines.ISpline
    {
        public UnityEngine.ComputeBuffer CurveLengths { get; }
        public UnityEngine.ComputeBuffer Curves { get; }
        public UnityEngine.Vector4 Info { get; }
        public SplineComputeBufferScope(T spline) {}
        public void Bind(UnityEngine.ComputeShader shader, int kernel, string info, string curves, string lengths);
        public virtual void Dispose();
        public void Upload();
    }

    [UnityEngine.Icon(@"Packages/com.unity.splines/Editor/Resources/Icons/KnotPlacementTool.png")] public sealed class SplineContainer : UnityEngine.MonoBehaviour, UnityEngine.Splines.ISplineProvider
    {
        public UnityEngine.Splines.Spline Spline { get; set; }
        public SplineContainer() {}
        public float CalculateLength();
        public bool Evaluate(float t, out Unity.Mathematics.float3 position, out Unity.Mathematics.float3 tangent, out Unity.Mathematics.float3 upVector);
        public Unity.Mathematics.float3 EvaluateAcceleration(float t);
        public Unity.Mathematics.float3 EvaluatePosition(float t);
        public Unity.Mathematics.float3 EvaluateTangent(float t);
        public Unity.Mathematics.float3 EvaluateUpVector(float t);
    }

    [System.Reflection.DefaultMember(@"Item")] public class SplineData<T> : System.Collections.Generic.IEnumerable<UnityEngine.Splines.DataPoint<T>>, System.Collections.IEnumerable
    {
        public event System.Action changed;
        public int Count { get; }
        public UnityEngine.Splines.DataPoint<T> this[int index] { get; set; }
        public UnityEngine.Splines.PathIndexUnit PathIndexUnit { get; set; }
        public SplineData() {}
        public SplineData(System.Collections.Generic.IEnumerable<UnityEngine.Splines.DataPoint<T>> dataPoints) {}
        public SplineData(T init) {}
        public void Add(UnityEngine.Splines.DataPoint<T> dataPoint);
        public void Add(float t, T data);
        public void Clear();
        public void ConvertPathUnit<TS>(TS spline, UnityEngine.Splines.PathIndexUnit toUnit) where TS : UnityEngine.Splines.ISpline;
        public T Evaluate<TSpline, TInterpolator>(TSpline spline, float t, TInterpolator interpolator) where TSpline : UnityEngine.Splines.ISpline where TInterpolator : UnityEngine.Splines.IInterpolator<T>;
        public T Evaluate<TSpline, TInterpolator>(TSpline spline, float t, UnityEngine.Splines.PathIndexUnit indexUnit, TInterpolator interpolator) where TSpline : UnityEngine.Splines.ISpline where TInterpolator : UnityEngine.Splines.IInterpolator<T>;
        [System.Runtime.CompilerServices.IteratorStateMachine(typeof(UnityEngine.Splines.SplineData<>))] public virtual System.Collections.Generic.IEnumerator<UnityEngine.Splines.DataPoint<T>> GetEnumerator();
        public float GetNormalizedTime(UnityEngine.Splines.NativeSpline spline, float time);
        public void RemoveAt(int index);
        public void SetDataPoint(int index, UnityEngine.Splines.DataPoint<T> value);
        public void SetKeyframeNoSort(int index, UnityEngine.Splines.DataPoint<T> value);
        public void SortIfNecessary();
    }

    [System.AttributeUsage(256)] public abstract class SplineDataHandleAttribute : System.Attribute
    {
        protected SplineDataHandleAttribute() {}
    }

    public static class SplineFactory
    {
        public static UnityEngine.Splines.Spline CreateLinear(System.Collections.Generic.IList<Unity.Mathematics.float3> positions, bool closed = False);
        public static UnityEngine.Splines.Spline CreateRoundedSquare(float radius, float rounding);
        public static UnityEngine.Splines.Spline CreateSquare(float radius);
    }

    public static class SplineGizmoUtility
    {
        public static void DrawGizmos(UnityEngine.Splines.ISplineProvider provider);
    }

    public enum SplineType
    {
        public const UnityEngine.Splines.SplineType Bezier = 1;
        public const UnityEngine.Splines.SplineType CatmullRom = 0;
        public const UnityEngine.Splines.SplineType Linear = 2;
        public byte value__;
    }

    [System.Runtime.CompilerServices.Extension] public static class SplineUtility
    {
        public const int DrawResolutionDefault = 10;
        public const int PickResolutionDefault = 4;
        public const int PickResolutionMax = 64;
        public const int PickResolutionMin = 2;
        [System.Runtime.CompilerServices.Extension] public static float CalculateLength(UnityEngine.Splines.Spline spline, Unity.Mathematics.float4x4 transform);
        [System.Runtime.CompilerServices.Extension] public static float ConvertIndexUnit<T>(T spline, float t, UnityEngine.Splines.PathIndexUnit originalTimeUnit, UnityEngine.Splines.PathIndexUnit targetPathUnit) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static float CurveToSplineInterpolation<T>(T spline, float curve) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static bool Evaluate<T>(T spline, float t, out Unity.Mathematics.float3 position, out Unity.Mathematics.float3 tangent, out Unity.Mathematics.float3 upVector) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static Unity.Mathematics.float3 EvaluateAcceleration<T>(T spline, float t) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static float EvaluateCurvature<T>(T spline, float t) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static Unity.Mathematics.float3 EvaluateCurvatureCenter<T>(T spline, float t) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static Unity.Mathematics.float3 EvaluatePosition<T>(T spline, float t) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static Unity.Mathematics.float3 EvaluateTangent<T>(T spline, float t) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static Unity.Mathematics.float3 EvaluateUpVector<T>(T spline, float t) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static UnityEngine.Bounds GetBounds<T>(T spline) where T : UnityEngine.Splines.ISpline;
        public static float GetNearestPoint<T>(T spline, Unity.Mathematics.float3 point, out Unity.Mathematics.float3 nearest, out float time, int resolution = 4, int iterations = 2) where T : UnityEngine.Splines.ISpline;
        public static float GetNearestPoint<T>(T spline, UnityEngine.Ray ray, out Unity.Mathematics.float3 nearest, out float time, int resolution = 4, int iterations = 2) where T : UnityEngine.Splines.ISpline;
        public static float GetNormalizedT<T>(T spline, float time, UnityEngine.Splines.PathIndexUnit originalTimeUnit) where T : UnityEngine.Splines.ISpline;
        [System.Runtime.CompilerServices.Extension] public static Unity.Mathematics.float3 GetPointAtLinearDistance<T>(T spline, float fromTime, float relativeDistance, out float resultPointTime) where T : UnityEngine.Splines.ISpline;
        public static int GetSegmentCount(float length, int resolution);
        public static void SetPivot(UnityEngine.Splines.SplineContainer container, UnityEngine.Vector3 position);
        [System.Runtime.CompilerServices.Extension] public static int SplineToCurveInterpolation<T>(T spline, float splineT, out float curveT) where T : UnityEngine.Splines.ISpline;
    }
}

namespace UnityEngine.Splines.Interpolators
{
    public struct LerpColor : UnityEngine.Splines.IInterpolator<UnityEngine.Color>
    {
        public virtual UnityEngine.Color Interpolate(UnityEngine.Color a, UnityEngine.Color b, float t);
    }

    public struct LerpFloat : UnityEngine.Splines.IInterpolator<float>
    {
        public virtual float Interpolate(float a, float b, float t);
    }

    public struct LerpFloat2 : UnityEngine.Splines.IInterpolator<Unity.Mathematics.float2>
    {
        public virtual Unity.Mathematics.float2 Interpolate(Unity.Mathematics.float2 a, Unity.Mathematics.float2 b, float t);
    }

    public struct LerpFloat3 : UnityEngine.Splines.IInterpolator<Unity.Mathematics.float3>
    {
        public virtual Unity.Mathematics.float3 Interpolate(Unity.Mathematics.float3 a, Unity.Mathematics.float3 b, float t);
    }

    public struct LerpFloat4 : UnityEngine.Splines.IInterpolator<Unity.Mathematics.float4>
    {
        public virtual Unity.Mathematics.float4 Interpolate(Unity.Mathematics.float4 a, Unity.Mathematics.float4 b, float t);
    }

    public struct LerpQuaternion : UnityEngine.Splines.IInterpolator<Unity.Mathematics.quaternion>
    {
        public virtual Unity.Mathematics.quaternion Interpolate(Unity.Mathematics.quaternion a, Unity.Mathematics.quaternion b, float t);
    }

    public struct SlerpQuaternion : UnityEngine.Splines.IInterpolator<Unity.Mathematics.quaternion>
    {
        public virtual Unity.Mathematics.quaternion Interpolate(Unity.Mathematics.quaternion a, Unity.Mathematics.quaternion b, float t);
    }

    public struct SmoothStepFloat : UnityEngine.Splines.IInterpolator<float>
    {
        public virtual float Interpolate(float a, float b, float t);
    }

    public struct SmoothStepFloat2 : UnityEngine.Splines.IInterpolator<Unity.Mathematics.float2>
    {
        public virtual Unity.Mathematics.float2 Interpolate(Unity.Mathematics.float2 a, Unity.Mathematics.float2 b, float t);
    }

    public struct SmoothStepFloat3 : UnityEngine.Splines.IInterpolator<Unity.Mathematics.float3>
    {
        public virtual Unity.Mathematics.float3 Interpolate(Unity.Mathematics.float3 a, Unity.Mathematics.float3 b, float t);
    }

    public struct SmoothStepFloat4 : UnityEngine.Splines.IInterpolator<Unity.Mathematics.float4>
    {
        public virtual Unity.Mathematics.float4 Interpolate(Unity.Mathematics.float4 a, Unity.Mathematics.float4 b, float t);
    }
}
